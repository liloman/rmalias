#!/usr/bin/env bash
# rmalias - rm compatible layer for trash


#############
#  GLOBALS  #
#############

readonly software=${0##*/}
readonly version="0.1"
readonly LC_ALL=C
readonly RM_CMD="$(which rm)"
[[ -z $RM_CMD ]] && { echo "$software: command 'rm' was not found." >&2; exit 1; }
# get path of trash.It depends on the installed version of the trash-cli package
readonly TRASH_CMD="$(which trash-put || which trash)"
[[ -z $TRASH_CMD ]] && { echo "$software: you need 'trash-put' for using this software." >&2; exit 1; }
# true to get DEBUG information
DEBUG=0

#Global array for sortDirs (recursive option)
declare -a dirsRecursive
#STDOUT from trash-put
STDOUT=
#exit from trash-put
ERROR=0
#default exit
EXITCODE=0
#Current arg processing
CURRENT_ARG=
# default option values
parents=false             
verbose=false            
force=false            
recursive=false            
doingRecursive=false
emptydirs=false            

#For sortDirs
shopt -s globstar 

#Sort dirs by further and alphabetically
function sortDirs() {
local max=0 depth dlen link ref base="$1"
#remove trailing /
base="${base%/}"

for dir in "$base"/**/; do
    depth="${dir//[^\/]}"
    dlen=${#depth}
    (( $dlen > max )) && { max=$dlen; declare -a dirs$max; }
    #To work with spaces
    eval "dirs$dlen+=( \"\$dir\" )"
done
 
while (( max > 0 )); do
  link=dirs$max
  ref="${link}[@]"
  temp=( "${!ref}" )
  dirsRecursive+=( "${!ref}" )
  (( max --))
done

[[ $DEBUG == 2 ]] && echo "sortedDirs tam:${#dirsRecursive[@]}--> ${dirsRecursive[@]}"
}

function usage() {
echo "Try '$software --help' for more information."
exit 1
}

function deletedir() {
local dir="$1"
[[ $DEBUG == 2 ]] && echo "deletedir: $dir"

[[ -z $dir ]] && { EXITCODE=1; echo "$software: cannot remove '$dir': No such file or directory"; return ; }

checkValid "$dir"
}


function checkValid() {
local dir="$1" 
local dontPrint=false found=false
[[ $DEBUG == 2 ]] && echo "CheckValid: dir:$dir"

#Check if already deleted from dirsRecursive
if [[ $doingRecursive == true ]]; then
    for i in ${!dirsRecursive[@]}; do
        [[ ${dirsRecursive[i]} == $dir ]] && found=true
    done
    [[ $DEBUG == 2 ]] && echo "found: $found --> $dir"
    [[ $found == false ]] &&  return;
fi

#Recursive option only for dirs
if [[ $recursive == true && $doingRecursive == false && -d $dir ]]; then
    doingRecursive=true
    sortDirs "$dir"
    for i in ${!dirsRecursive[@]}; do
        checkValid "${dirsRecursive[i]}" 
    done
    #Clean up for next arguments
    unset dirsRecursive
    doingRecursive=false
    #Dont delete arg base dir cause it's already included in dirsRecursive
    return
# No such file or directory
elif [[ $force == false && ! -e $dir ]]; then  
    ERROR=1
    STDOUT="$software: cannot remove '$dir': No such file or directory"
elif [[ $force == true && ! -e $dir ]]; then  
    dontPrint=true
# Directory
elif [[ -d $dir && $recursive == false ]]; then 
    if [[ $emptydirs == false ]]; then  
        ERROR=1
        STDOUT="$software: cannot remove '$dir': Is a directory"
   # directory not empty
    elif [[ -n $(shopt -s nullglob dotglob;echo "$dir"/*) ]]; then
        ERROR=1
        local msg="directory "
        [[ $CURRENT_ARG = $dir ]] && msg=
        STDOUT="$software: cannot remove $msg'$dir': Directory not empty" 
    fi
#Permission write on directory or execution on parent dir for dirs
elif [[ -d $dir ]] && [[ ! -w $dir || ! -x $dir/..  ]]; then
    ERROR=1
    dir=${dir%/}
    for file in $dir/*; do
        STDOUT+="$software: cannot remove '$file': Permission denied"$'\n'
    done
#No permission on parent when delete a file
elif [[ ! -d $dir && ! -w ${dir%/*} ]]; then
    ERROR=1
    STDOUT="$software: cannot remove '$dir': Permission denied"$'\n'
fi

[[ $dontPrint == false && $ERROR = 0 ]] && trashput "$dir" ||  showErrors  "$dir"
}


function trashput() {
# Uncomment for coreutils > 8.13 (Ubuntu > Precise)
# local dir="$(realpath -Pe --relative-base="$PWD" "$1")" 
# realpath relative-base in bash
local dir="$(realpath "$1")" len="${#PWD}" msg
[[ ${dir:0:len} == $PWD ]] && dir="${dir/$PWD\//}"
#end realpath --relative-base

local cmd="$TRASH_CMD"

[[ $verbose = true ]] && cmd+=" --verbose"

cmd+=" \"$dir\""

[[ $DEBUG == 1 ]] && echo "$software: executing $cmd"

[[ -d $dir ]] && msg="removed directory: '$dir'" || msg="removed '$dir'"

STDOUT="$(eval "$cmd" 2>&1)"
[[ $? != 0 ]] && EXITCODE=1

if [[ $ERROR != 0 && $verbose = true ]]; then 
    while IFS= read -r line; do
        [[ -n $line ]] && echo "$line"
    done <<< "$STDOUT"
fi

#Show verboses or errors
[[  $ERROR = 0 ]] && showVerbose "$msg" ||  showErrors "$dir"
}


function showVerbose() {
[[ $verbose = false ]] && return
local msg="$1"

echo "$msg"
}

function showErrors() {
local dir="$1" len temp
[[ $DEBUG == 2 ]] && echo "showErrors ERROR=$ERROR,STDOUT=$STDOUT from ${FUNCNAME[1]}"

#if first error
[[ $EXITCODE = 0 ]] && EXITCODE=$ERROR

#Print them all
while IFS= read -r line; do
    [[ -n $line ]] && echo "$line"
done <<< "$STDOUT"

#Reset 
STDOUT=
ERROR=0

#Recursive option
if [[ $doingRecursive == true ]]; then
    #Remove its parents from dirsRecursive
    for i in ${!dirsRecursive[@]}; do
        temp="${dirsRecursive[$i]}"
        len=${#temp}
        [[ $temp == ${dir:0:len} ]] && unset dirsRecursive[$i]
    done
fi
}


# use getopt to parse parameters
if ! OPTIONS=$(getopt -n "$software" -o vhfrRd -l "dir" -l "recursive" -l "force" -l "verbose" -l "help" -l "version" -- "$@"); then
    usage
    exit 1
fi
eval set -- "${OPTIONS}"


# parse options
while true; do
    case "$1" in

        "-d"|"--dir")
            emptydirs=true
            shift
            ;;

        "-f"|"--force")
            force=true
            shift
            ;;

        "-v"|"--verbose")
            [[ $DEBUG = 1 ]] && DEBUG=2
            [[ $DEBUG = 0 && $verbose = true ]] && DEBUG=1
            verbose=true
            shift
            ;;

        "-R"|"-r"|"--recursive")
            recursive=true
            shift
            ;;

        "-h")
            echo "$software: invalid option -- 'h'"
            usage
            ;;

        "--help")
            trash="${TRASH_CMD##*/}"
            echo "Put empty directories in trash using the '$trash' command in a way that is,
            otherwise as '$trash' itself, compatible to GNUs 'rm'.
            see $TRASH_CMD --help
            Usage: rm [OPTION]... [FILE]...
            Remove (unlink) the FILE(s).

            -f, --force           ignore nonexistent files and arguments, never prompt
            -i                    prompt before every removal
            -I                    prompt once before removing more than three files, or
            when removing recursively; less intrusive than -i,
            while still giving protection against most mistakes
                --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                always (-i); without WHEN, prompt always
                --one-file-system  when removing a hierarchy recursively, skip any
                directory that is on a file system different from
                that of the corresponding command line argument
                --no-preserve-root  do not treat '/' specially
                --preserve-root   do not remove '/' (default)
                -r, -R, --recursive   remove directories and their contents recursively
                -d, --dir             remove empty directories
                -v, --verbose         explain what is being done
                --help     display this help and exit
                --version  output version information and exit

                By default, rm does not remove directories.  Use the --recursive (-r or -R)
                option to remove each listed directory, too, along with all of its contents.

                To remove a file whose name starts with a '-', for example '-foo',
                use one of these commands:
                rm -- -foo

                rm ./-foo

                Note that if you use rm to remove a file, it might be possible to recover
                some of its contents, given sufficient expertise and/or time.  For greater
                assurance that the contents are truly unrecoverable, consider using shred.

                Please report bugs using GitHub at <https://github.com/liloman/rmalias>.
                Besides, you will find general help and information about $software there."
            exit 0
            ;;

        "--version")
            echo "rmalias $version" 
            echo "Copyright (C) 2015 Carlos Morata"
            echo "License GPLv3: GNU GPL version 3 only <http://gnu.org/licenses/gpl.html>."
            echo "This is free software: you are free to change and redistribute it."
            echo "There is NO WARRANTY, to the extent permitted by law."
            echo
            echo "See also: <https://github.com/liloman/rmalias"
            exit 0
            ;;

        "--")
            shift
            break
            ;;
        \?)
            echo "Invalid options: -$OPTARG" >&2
            ;;

        *)
            echo "$software: execution of getopt failed" >&2
            usage
            ;;
    esac
done

# no arguments given
if [[ $# = 0 ]]; then
    echo "$software: missing operand" >&2
    usage
fi


# parse arguments
while (( $# > 0 )); do
    CURRENT_ARG="$1"
    deletedir "$1"
    shift
done

exit $EXITCODE


