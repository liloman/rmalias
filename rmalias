#!/usr/bin/env bash
# rmalias - rm compatible layer for trash


#############
#  GLOBALS  #
#############

readonly software=${0##*/}
readonly version="0.1"
readonly LC_ALL=C
readonly RM_CMD="$(which rm)"
[[ -z $RM_CMD ]] && { echo "$software: command 'rm' was not found." >&2; exit 1; }
# get path of trash.It depends on the installed version of the trash-cli package
readonly TRASH_CMD="$(which trash-put || which trash)"
[[ -z $TRASH_CMD ]] && { echo "$software: you need 'trash-put' for using this software." >&2; exit 1; }
# true to get DEBUG information
DEBUG=0

#Global array for sortDirs (recursive option)
declare -a dirsRecursive
#File for getDirs (recursive option)
readonly fileDirs="/tmp/.fileDirs"
#STDOUT from trash-put
STDOUT=
#exit from trash-put
ERROR=0
#default exit
EXITCODE=0
#Current arg processing
CURRENT_ARG=
# default option values
parents=false             
verbose=false            
force=false            
recursive=false            
doingRecursive=false
emptydirs=false            

#For older getDirs
#Sort dirs by further and alphabetically
#  ** doesn't pass through dirs without x permission as find does :(
#shopt -s globstar 
#For listing files
shopt -s nullglob dotglob


#Sort dirs by modification time
function sortDirs() {
[[ ! -f $fileDirs ]] && return 
local tempFile="/tmp/.listing$RANDOM"
sort -r -k1 -k2 $fileDirs > $tempFile

while IFS= read -r line; do
    echo ${line#*/}
done < $tempFile
}


#Insert dirs in dirsRecursive
function getDirs() {
local max=0 base="$1" tempFile="/tmp/.listing$RANDOM" filemap
local regex='find:[[:space:]][[:punct:]](.*)[[:punct:]]: Permission denied' 
#remove trailing /
base="${base%/}"

find "$base/" -mindepth 1 -maxdepth 1 -type d -printf '%T@\t%p\n' &>$tempFile

while IFS= read -r line; do
    read time cur <<< $line
    [[ $cur =~ $regex ]] && cur="${BASH_REMATCH[1]}"
    time=${time/./}
    echo "$time/$cur" >> $fileDirs
    getDirs "$cur"
done < $tempFile

rm $tempFile
}

function usage() {
echo "Try '$software --help' for more information."
exit 1
}

function deletedir() {
local dir="$1"
(($DEBUG >= 2)) && echo "deletedir: $dir"

# [[ -z $dir && $force == false ]] && { EXITCODE=1; echo "$software: cannot remove '$dir': No such file or directory"; return ; }

checkValid "$dir"
}


function checkValid() {
local dir="$1"  dontPrint=false temp
local found=false base
(($DEBUG >= 2)) && echo "CheckValid: dir:$dir"

(($DEBUG >= 3)) && set -x 

#Check if dir was already deleted from dirsRecursive
if [[  $doingRecursive == true && -d $dir ]]; then
    for i in ${!dirsRecursive[@]}; do
        [[ ${dirsRecursive[i]} == $dir ]] && found=true
    done
    (($DEBUG >= 2)) && echo "notDeleted: $found --> $dir"
    [[ $found == false ]] &&  return;
fi

#If it's a dir
if [[ -d $dir ]]; then
    #Recursive option only for dirs not parsed already
    if [[ $recursive == true && $doingRecursive == false ]]; then
        doingRecursive=true
        #Get all subdirs 
        getDirs "$dir"
        #Sort it all by modification time
        while IFS= read -r line; do
            dirsRecursive+=("$line")
        done < <(sortDirs)
        dirsRecursive+=("$dir")
        for i in ${!dirsRecursive[@]}; do
            base="${dirsRecursive[i]}" 
            #Remove only files of each subdir (base has a trailing /)
            for file in "$base"*; do
                [[ ! -d $file ]] && checkValid "$file" 
            done
            #Remove subdir when all files have been checked/deleted
            checkValid "$base"
        done
        #Clean up for next arguments
        rm -f $fileDirs
        unset dirsRecursive
        doingRecursive=false
        #Dont delete arg base dir cause it's already included in dirsRecursive
        return
    # Not recursive or doingRecursive
    else
    # elif [[ $recursive == false ]]; then 
            #Permission write on directory or execution on parent dir for dirs
        if [[ ! -w $dir || ! -x $dir/..  ]]; then
            ERROR=1
            dir=${dir%/}
            for file in $dir/*; do
                STDOUT+="$software: cannot remove '$file': Permission denied"$'\n'
            done
            # directory not empty
        elif [[ $recursive == false && $emptydirs == false ]]; then  
            ERROR=1
            STDOUT="$software: cannot remove '$dir': Is a directory"
        elif [[ $recursive == false && -n $(echo "$dir"/*) ]]; then
            ERROR=1
            local msg="directory "
            [[ $CURRENT_ARG = $dir ]] && msg=
            STDOUT="$software: cannot remove $msg'$dir': Directory not empty" 
        fi
    fi
#if it doesn't exist and not a broken symlink
elif [[ ! -e $dir && ! -h $dir ]]; then  
    # No such file or directory
    if [[ $force == false ]]; then
        ERROR=1
        STDOUT="$software: cannot remove '$dir': No such file or directory"
    else
        dontPrint=true
    fi
#Not dirs (regular files, symlinks ...)
else
    #Relative file so
    [[ ${dir:0:1} != / ]] && base="$PWD/$dir"
    if [[ ! -w ${base%/*} || ! -x ${base%/*}  ]]; then
        ERROR=1
        STDOUT="$software: cannot remove '$dir': Permission denied"$'\n'
    fi
fi

(($DEBUG >= 3)) && set +x 
[[ $ERROR == 0  && $dontPrint == false ]] && trashput "$dir" ||  showErrors  "$dir" 
}


function trashput() {
local dir="$1"  msg
(($DEBUG >= 2)) && echo "trashput:$dir"

local cmd="$TRASH_CMD"

[[ $verbose = true ]] && cmd+=" --verbose"

cmd+=" \"$dir\""

(($DEBUG >= 1)) && echo "$software: executing $cmd"


[[ -d $dir ]] && msg="removed directory: '${dir%/}'" || msg="removed '$dir'"

STDOUT="$(eval "$cmd" 2>&1)"
[[ $? != 0 && $force == false ]] && EXITCODE=1

if [[ $ERROR != 0 && $verbose = true ]]; then 
    while IFS= read -r line; do
        [[ -n $line ]] && echo "$line"
    done <<< "$STDOUT"
fi

#Show verboses or errors
[[  $ERROR = 0 ]] && showVerbose "$msg" ||  showErrors "$dir" false
}


function showVerbose() {
[[ $verbose = false ]] && return
local msg="$1"

echo "$msg"
}

function showErrors() {
local dir="$1" len temp 
(($DEBUG >= 2)) && echo "showErrors ERROR=$ERROR,STDOUT=$STDOUT from ${FUNCNAME[1]}"

#if first error
[[ $EXITCODE = 0 ]] && EXITCODE=$ERROR

#Print them all
while IFS= read -r line; do
    [[ -n $line ]] && echo "$line"
done <<< "$STDOUT"

#Reset 
STDOUT=
ERROR=0

#Recursive option
if [[ $doingRecursive == true ]]; then
    #Remove its parents from dirsRecursive
    for i in ${!dirsRecursive[@]}; do
        temp="${dirsRecursive[$i]}"
        len=${#temp}
        [[ $temp == ${dir:0:len} ]] && { dirsRecursive[$i]="" ; (($DEBUG >= 2)) && echo "deleted dirsRecursive:$temp " ;}
    done
fi
}


# use getopt to parse parameters
if ! OPTIONS=$(getopt -n "$software" -o vhfrRd -l "dir" -l "recursive" -l "force" -l "verbose" -l "help" -l "version" -- "$@"); then
    usage
    exit 1
fi
eval set -- "${OPTIONS}"


# parse options
while true; do
    case "$1" in

        "-d"|"--dir")
            emptydirs=true
            shift
            ;;

        "-f"|"--force")
            force=true
            shift
            ;;

        "-v"|"--verbose")
            [[ $DEBUG = 2 ]] && DEBUG=3
            [[ $DEBUG = 1 ]] && DEBUG=2
            [[ $DEBUG = 0 && $verbose = true ]] && DEBUG=1
            verbose=true
            shift
            ;;

        "-R"|"-r"|"--recursive")
            recursive=true
            shift
            ;;

        "-h")
            echo "$software: invalid option -- 'h'"
            usage
            ;;

        "--help")
            trash="${TRASH_CMD##*/}"
            echo "Put empty directories in trash using the '$trash' command in a way that is,
            otherwise as '$trash' itself, compatible to GNUs 'rm'.
            see $TRASH_CMD --help
            Usage: rm [OPTION]... [FILE]...
            Remove (unlink) the FILE(s).

            -f, --force           ignore nonexistent files and arguments, never prompt
            -i                    prompt before every removal
            -I                    prompt once before removing more than three files, or
            when removing recursively; less intrusive than -i,
            while still giving protection against most mistakes
                --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                always (-i); without WHEN, prompt always
                --one-file-system  when removing a hierarchy recursively, skip any
                directory that is on a file system different from
                that of the corresponding command line argument
                --no-preserve-root  do not treat '/' specially
                --preserve-root   do not remove '/' (default)
                -r, -R, --recursive   remove directories and their contents recursively
                -d, --dir             remove empty directories
                -v, --verbose         explain what is being done
                --help     display this help and exit
                --version  output version information and exit

                By default, rm does not remove directories.  Use the --recursive (-r or -R)
                option to remove each listed directory, too, along with all of its contents.

                To remove a file whose name starts with a '-', for example '-foo',
                use one of these commands:
                rm -- -foo

                rm ./-foo

                Note that if you use rm to remove a file, it might be possible to recover
                some of its contents, given sufficient expertise and/or time.  For greater
                assurance that the contents are truly unrecoverable, consider using shred.

                Please report bugs using GitHub at <https://github.com/liloman/rmalias>.
                Besides, you will find general help and information about $software there."
            exit 0
            ;;

        "--version")
            echo "rmalias $version" 
            echo "Copyright (C) 2015 Carlos Morata"
            echo "License GPLv3: GNU GPL version 3 only <http://gnu.org/licenses/gpl.html>."
            echo "This is free software: you are free to change and redistribute it."
            echo "There is NO WARRANTY, to the extent permitted by law."
            echo
            echo "See also: <https://github.com/liloman/rmalias"
            exit 0
            ;;

        "--")
            shift
            break
            ;;
        \?)
            echo "Invalid options: -$OPTARG" >&2
            ;;

        *)
            echo "$software: execution of getopt failed" >&2
            usage
            ;;
    esac
done

# no arguments given
if [[ $# = 0 ]]; then
    echo "$software: missing operand" >&2
    usage
fi


#Let' s be sure
rm -f $fileDirs

# parse arguments
while (( $# > 0 )); do
    # Uncomment for coreutils > 8.13 (Ubuntu > Precise)
    # local dir="$(realpath -se --relative-base="$PWD" "$1")" 
    # realpath relative-base in bash
    current="$(realpath -s "$1" 2>/dev/null)" len="${#PWD}" 
    [[ ${current:0:len} == $PWD ]] && current="${current/$PWD\//}"
    if [[ -z $current && $force == false ]]; then  
        EXITCODE=1; 
        STDOUT="$software: cannot remove '$current': No such file or directory";
        showErrors "$current" false
    else
        #end realpath --relative-base
        CURRENT_ARG="$current"
        deletedir "$current"
    fi
    unset current CURRENT_ARG
    shift
done

exit $EXITCODE


